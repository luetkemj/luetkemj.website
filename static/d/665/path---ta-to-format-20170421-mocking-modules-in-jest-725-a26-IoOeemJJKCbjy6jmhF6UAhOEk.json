{"data":{"markdownRemark":{"html":"<p>I've recently given jest a try for unit testing. Until now I have really only ever used Mocha. One of the things that I always struggled with was mocking functions. In scribe, many of the generators make heavy use of random numbers. Testing random numbers is challenging and more than a little uncertain. Testing that a result is within a range is far less satisfying than an exact value.</p>\n<p>Lodash is used heavily in a weather generator I am working on. The only lodash functionality I need to mock at the moment is random(). Jest automatically mocks modules for you which is cool but by default the mocks return nothing. In order to get my tests to work with the default mocks is to mock all of the lodash functions in the generator. Yuck.</p>\n<p>Fortunately there is a way to mock only what you need. There seems to be a lot of <a href=\"https://github.com/facebook/jest/issues/936\">confusion</a> online regarding how to implement this. Here's how I got it working.</p>\n<pre><code class=\"language-javascript\">// myModule.js\nimport { random } from 'lodash';\n\nexport function testRandomMock() {\n  return random(1, 10);\n}\n\n\n// myModule.test.js\nimport * as myModule from './myModule.js';\n\n// tell jest not to mock lodash\njest.unmock('lodash');\n// require the actual module so that we can mock exports on the module\nconst lodash = require.requireActual('lodash');\n\ntest('random should be 1', () => {\n  // mock lodash random to return the value 1 in first test\n  lodash.random = jest.fn(() => 1);\n  expect(myModule.testRandomMock(1)).toBe(1);\n});\n\ntest('random should be 2', () => {\n  // mock lodash random to return the value 2 in second test\n  lodash.random = jest.fn(() => 2);\n  expect(myModule.testRandomMock(2)).toBe(2);\n});\n</code></pre>\n<h3>UPDATE 180204</h3>\n<p>As Darth mentions below in the comments the above example does not actually address the <a href=\"https://github.com/facebook/jest/issues/936\">confusion</a> in the discussion on github.</p>\n<p>So how do we deal with mocking a function created and used internally by the same module you are testing?</p>\n<p>Suppose you have module.js and want to mock <code>baz</code> when testing <code>foo</code>.</p>\n<pre><code class=\"language-javascript\">// module.js\nexport function foo() {\n  return baz();\n}\n\nexport function baz() {\n  return 'buzz';\n}\n</code></pre>\n<p>If anyone knows how to do this without modifying module.js I'd love to know!</p>\n<p>However, if you are willing to make a small change to module.js...</p>\n<pre><code class=\"language-javascript\">// module.js\nexport function foo() {\n  return lib.baz();\n}\n\nexport function baz() {\n  return 'buzz';\n}\n\nexport const lib = {\n  baz,\n};\n</code></pre>\n<p><code>lib.baz</code> can now be now be mocked like so</p>\n<pre><code class=\"language-javascript\">// module.test.js\nimport * as module from './module';\n\nmodule.lib.baz = jest.fn(() => 'bar');\n\ndescribe('foo', () => {\n  it('should work', () => {\n    expect(module.foo()).toBe('bar');\n  });\n});\n</code></pre>\n<p>Try it out on <a href=\"https://github.com/luetkemj/jest-mock-test\">github</a>!</p>","frontmatter":{"date":"170421","title":"Mocking specific module functions with jest","illustration":null}}},"pageContext":{"nextPostPath":"/taToFormat/20170228/the-state-of-scribe","previousPostPath":"/taToFormat/20170529/consistency"}}