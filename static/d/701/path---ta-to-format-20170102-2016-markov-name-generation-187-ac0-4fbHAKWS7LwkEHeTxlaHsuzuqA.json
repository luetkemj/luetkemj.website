{"data":{"markdownRemark":{"html":"<p>About six months ago I began writing <a href=\"https://github.com/luetkemj/scribe\">Scribe</a> - a toolkit for dungeon masters. There are no plans to ever market or even release the project beyond it's public repo on github. It's raison d'etre is simply to provide a set of interesting problems for me solve as I learn Javascript.</p>\n<p>As I was researching existing tools for roleplaying games I found this neat <a href=\"https://donjon.bin.sh/name/markov.html\">fantasy name generator</a> written in Javascript that uses <a href=\"https://en.wikipedia.org/wiki/Markov_chain\">Markov chains</a> to create new names based on the style of a sample set. A use case for this is to create random and new names that sound elvish or dwarven.</p>\n<p>Being as I had never heard of Markov or his chains I had to do a bit of research to figure out how this generator worked and why it used Markov chains in the first place.</p>\n<p>There is a quick explanation on <a href=\"https://donjon.bin.sh/code/name/\">Donjon</a> as well as the source for use in personal projects. But as I mentioned before Scribe is about learning more than it is about creating an actual piece of software and as such I decided to take a stab at writing my own version.</p>\n<p>First we'll take a quick look at Markov chains. We will then look at how they can be used to solve our own problem. Finally we will talk briefly about this theory in practice and how we might expand, experiment, and improve further.</p>\n<h3>Markov Chains</h3>\n<p>Suppose we wanted to create a mock weather forecast for a fantasy game. We might decide to have two weather states - sunny and rainy. To create our mock forecast we could just randomly switch between the two each day. This might create a forecast like the following:</p>\n<p>s s <strong>R</strong> s <strong>R</strong> <strong>R</strong> s s s s <strong>R</strong> s <strong>R</strong> s <strong>R</strong> s s <strong>R</strong> <strong>R</strong> s <strong>R</strong> <strong>R</strong></p>\n<p>As expected our days randomly jump from sun to rain and rain to sun. However if we are trying to model a forecast that represents reality this approach fails.</p>\n<p>A way to create a more realistic sequence might be to switch between rain and sun not randomly but based on the likelihood that a sunny day will be followed by rain or more sun. This approach might result in a sequence like the following:</p>\n<p>s s s s s s <strong>R</strong> <strong>R</strong> s s s s s s <strong>R</strong> <strong>R</strong> <strong>R</strong> <strong>R</strong> s s s s</p>\n<p>You may notice how the sequence now has a certain stickiness to it as opposed to the random jumpiness we began with.</p>\n<p>Given a system that steps through a series of states like our forecast, a Markov chain is simply a way to model the chance of moving from one given state to another.</p>\n<p>A model for our forecast may look like this:</p>\n<pre><code class=\"language-javascript\">{\n    sunny: {\n        sunny: 75%,\n        rainy: 25%\n    },\n    rainy: {\n        rainy: 40%,\n        sunny: 60%\n    }\n}\n</code></pre>\n<p>Our model predicts that on a sunny day we have a 75% percent chance that the next day will be sunny and a 25% chance that it will be rainy. Whereas on a rainy day we have a 40% chance that the next day will be rainy and a 60% chance it will be sunny.</p>\n<h3>How does this help us?</h3>\n<p>If you remember the problem we are attempting to solve is to generate names in the style of a sample set. We could try something rather simplistic like finding all the characters that appear in the sample set and scrambling them into new names but much like our weather example our results would be far too random and unlikely to sound much like our sample set.</p>\n<p>Instead we will use Markov chains in order to create a sequence of characters patterned after our sample set.</p>\n<p>First we need to know what characters occur in our sample set. A result with a Z or X in it would not be in the style of our sample set if it contained zero instances of Z or X.</p>\n<p>Given a sample set of <code>[sampson, samantha]</code> we would expect an array containing only unique characters from our set like <code>[s,a,m,p,o,n,t,h]</code>.</p>\n<p>In order to select subsequent characters in the style of our sample set we need to determine what characters proceed each character in our array of unique characters. An example model that contains this information might look like:</p>\n<pre><code class=\"language-javascript\">{\n    s: {a: 2, o: 1},\n    a: {m: 2, n: 1},\n    m: {p: 1, a: 1},\n    p: {s: 1},\n    o: {n: 1},\n    n: {t: 1},\n    t: {h: 1},\n    h: {a: 1}\n}\n</code></pre>\n<p>So from our object we can now see that the character 's' is followed by 'a' two times and 'o' once. Therefore whenever our current character is 's' we know it can only be followed by an 'a' or an 'o'. Furthermore we know that it will be followed by an 'a' twice as often as it will be followed by an 'o'.</p>\n<p>Here's a series of names beginning with 'S' generated with our model.</p>\n<p>'Samamam', 'Sontham', 'Santham', 'Samanth', 'Santhan', 'Samamps'.</p>\n<p>Some of these are a bit silly but notice how all of them sound similar to the seed names of Samantha and Sampson.</p>\n<h3>Theory in Practice</h3>\n<p>To see this in practice you can take a look at the <a href=\"https://github.com/luetkemj/scribe-name-generator/tree/3899d3865cd221680aaadc6213be23c48eb29891\">name generator</a> I'm working on for Scribe. While functional there are still many things to do that could improve the current implementation.</p>\n<h3>Improvements</h3>\n<p>I'd like to try breaking the names into character pairs or even syllables instead of individual characters to see how the results change. Currently the length of generated names is hardcoded but I would like to instead determine the length based on the sample set much the same way we determine the characters.</p>\n<h3>Experimentation</h3>\n<p>I'm interested in seeing the results as I tinker with the model and feed it larger data sets. What might happen if I recursively feed the model it's own results? Or purposely add mistakes to the set to allow the results to evolve much like DNA code errors?</p>\n<p>Curiosity abounds!</p>","frontmatter":{"date":"170102","title":"Markov Name Generation","illustration":null}}},"pageContext":{"nextPostPath":"/taToFormat/20170101/2016-year-in-review","previousPostPath":"/taToFormat/20170228/the-state-of-scribe"}}